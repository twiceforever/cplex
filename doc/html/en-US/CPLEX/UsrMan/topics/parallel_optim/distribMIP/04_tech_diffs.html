<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="© Copyright IBM Corporation 2017" />
<meta name="DC.Rights.Owner" content="© Copyright IBM Corporation 2017" />
<meta name="security" content="public" />
<meta name="Robots" content="index,follow" />
<meta name="DC.Type" content="topic" />
<meta name="DC.Title" content="Technical limits of distributed branch and bound" />
<meta name="abstract" content="Documents limits of distributed branch." />
<meta name="Description" content="Documents limits of distributed branch." />
<meta name="DC.subject" content="MIP, distributed computing and, Mixed Integer Programming (MIP), distributed MIP, no callbacks in, callback, not in distributed MIP, no warm starts in, warm start" />
<meta name="keywords" content="MIP, distributed computing and, Mixed Integer Programming (MIP), distributed MIP, no callbacks in, callback, not in distributed MIP, no warm starts in, warm start" />
<meta name="DC.Relation" scheme="URI" content="../../../../../CPLEX/UsrMan/topics/parallel_optim/distribMIP/01_distributed_mip_title_synopsis.html" />
<meta name="DC.Date" scheme="iso8601" content="2017-11-14" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="distribMIPtechdiffs" />
<meta name="DC.Language" content="en-us" />
<meta name="IBM.Country" content="ZZ" />
<!-- Licensed Materials - Property of IBM -->
<!-- US Government Users Restricted Rights -->
<!-- Use, duplication or disclosure restricted by -->
<!-- GSA ADP Schedule Contract with IBM Corp. -->
<link rel="stylesheet" type="text/css" href="../../../../.././ibmdita.css" />
<link rel="stylesheet" type="text/css" href="../../../../.././swg_info_common_opti.css" />
<link rel="Start" href="../../../../../CPLEX/UsrMan/topics/parallel_optim/distribMIP/01_distributed_mip_title_synopsis.html" />
<title>Technical limits of distributed branch and bound</title>
</head>
<body id="distribMIPtechdiffs"><div role="main">
<h1 class="title topictitle1">Technical limits of distributed branch and bound</h1>
<div class="body"><p class="shortdesc">Documents limits of distributed branch.</p>
<p class="p">If you are already familiar with solving a mixed integer program (MIP) by means of conventional 
CPLEX MIP optimization, there are a few technical differences in distributed parallel MIP optimization 
that are worth noting.</p>
<div class="section"><h2 class="title sectiontitle">No restarting a run from where it stopped</h2>
<p class="p">Distributed parallel MIP always starts from scratch. 
In contrast, with the conventional MIP optimizer, you can 
specify limits, reach them, and restart.
For example, you can specify a limit on the number of nodes to solve 
and solve your MIP conventionally with shared memory, stopping when 
the node limit occurs; you can then extend the limit on nodes to a greater 
number and invoke solve again. With conventional MIP with shared memory, the 
second solve takes up where the first solve stopped.</p>

<p class="p">This pattern of stopping and restarting from a previous point is not 
possible with distributed parallel MIP. If you attempt that scenario of 
solving to a node limit, stopping at the limit, extending the limit to a 
greater number, and restarting, distributed parallel MIP simply starts over 
from scratch (not from the state when it reached the previous limit).</p>
</div>
<div class="section"><h2 class="title sectiontitle">Mix and match still starts from scratch</h2>
<p class="p">Likewise, if you mix calls to conventional MIP with shared memory with calls 
to distributed parallel MIP, the call to distributed parallel MIP will always 
start from scratch. In fact, if you begin with distributed parallel MIP optimization, 
let it run to a limit (such as a time limit, node limit, solutions limit), and then  
invoke conventional MIP optimization, even the conventional MIP starts over 
from scratch. It does not use any of the information accumulated in the previous 
optimization.</p>
</div>
<div class="section"><h2 class="title sectiontitle">No legacy control or query callbacks</h2>
<p class="p">Distributed parallel MIP does not support legacy control callbacks.
Distributed parallel MIP does not support legacy query callbacks. </p>

<p class="p">For definitions of legacy informational, query, and control callbacks, see the topic 
<a class="xref" href="../../progr_adv/callbacks_basic/01_cb_title_synopsis.html" title="Introduces legacy optimization callbacks.">Using legacy optimization callbacks</a> 
in the <em class="ph i">CPLEX User's Manual</em>. </p>

</div>
<div class="section"><h2 class="title sectiontitle">Special considerations about legacy informational callbacks</h2> 
 
<p class="p"> 
You can use legacy informational callbacks with distributed parallel MIP in certain situations.  
An informational callback pertains to the master (not the workers).
Furthermore, during rampup, there is no uniquely defined tree. 
Consequently, callback information 
that depends on specifics of a branch and bound tree does not exist then. </p>

<p class="p">Because of the distributed aspects of a such an MIP application, special 
considerations apply to legacy informational callbacks in a distributed MIP application. 
For example, the legacy informational callback is called only at synchronization points 
during distributed MIP optimization; that is, less frequently than in 
conventional MIP optimization in shared memory. (There are other differences 
as well that arise from the different topology of distributed parallel optimization.)</p>

<div class="p">Specifically, when you query certain information by means of 
<a class="xref" href="../../../../../refcallablelibrary/cpxapi/getcallbackinfo.html" title="The routine CPXXgetcallbackinfo/CPXgetcallbackinfo accesses information about the current optimization process from within a user-written legacy callback function.">CPXXgetcallbackinfo and CPXgetcallbackinfo</a> 
in the Callable Library (C API), the following considerations apply:

    <ul class="ul"><li class="li">Queries about cut counts, such as 
    <span class="keyword apiname">CPX_CALLBACK_INFO_COVER_COUNT</span>, always 
    return 0 (zero).</li>
<li class="li">Queries about MIP kappa statistics, such as 
    <span class="keyword apiname">CPX_CALLBACK_INFO_KAPPA_MAX</span>, 
    result in the error message <span class="keyword apiname">CPXERR_NO_KAPPASTATS</span>.</li>
<li class="li">The number of threads, 
    as queried by <span class="keyword apiname">CPX_CALLBACK_INFO_USER_THREADS</span>, is 
    always 1 (one).
    </li>
<li class="li">The user thread index as identified by 
    <span class="keyword apiname">CPX_CALLBACK_INFO_MY_THREAD_NUM</span> is always 0 (zero).
    </li>
<li class="li">Queries about the current node count, the number of 
    nodes left, and the iteration count all return correct values during 
    distributed MIP tree search (that is, branch and bound) after ramp up terminates.
    However, during ramp up, the following queries always return 0 (zero):
        <ul class="ul"><li class="li"><span class="keyword apiname">CPX_CALLBACK_INFO_NODE_COUNT</span></li>
<li class="li"><span class="keyword apiname">CPX_CALLBACK_INFO_NODE_COUNT_LONG</span></li>
<li class="li"><span class="keyword apiname">CPX_CALLBACK_INFO_NODES_LEFT</span></li>
<li class="li"><span class="keyword apiname">CPX_CALLBACK_INFO_NODES_LEFT_LONG</span></li>
<li class="li"><span class="keyword apiname">CPX_CALLBACK_INFO_MIP_ITERATIONS</span></li>
<li class="li"><span class="keyword apiname">CPX_CALLBACK_INFO_MIP_ITERATIONS_LONG</span></li>
</ul>

    </li>
</ul>
</div>

<div class="p">Similar considerations apply to analogous queries in other APIs of CPLEX. 
For example, in the C++ API, special considerations about legacy informational callbacks 
and distributed MIP apply to these methods of the class 
<span class="keyword apiname">IloCplex::MIPInfoCallbackI</span>:
    <ul class="ul"><li class="li"><span class="keyword apiname">getNcuts</span> always returns 0 (zero).</li>
<li class="li"><span class="keyword apiname">getQuality</span>  throws an exception to convey the error message 
        <span class="keyword apiname">CPXERR_NO_KAPPASTATS</span>.</li>
<li class="li"><span class="keyword apiname">getUserThreads</span> always returns 1 (one).</li>
<li class="li"><span class="keyword apiname">getMyThreadNum</span> always returns 0 (zero).</li>
<li class="li"><span class="keyword apiname">getNnodes</span> returns 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">getNremainingNodes</span> returns 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">getNiterations</span> returns 0 (zero) during ramp up.</li>
</ul>
</div>

<div class="p">Likewise, in the Java API, special considerations about legacy informational callbacks 
and distributed MIP apply to these methods of the class 
<span class="keyword apiname">IloCplex.MIPInfoCallback</span>:
    <ul class="ul"><li class="li"><span class="keyword apiname">getNcuts</span> always returns 0 (zero).</li>
<li class="li"><span class="keyword apiname">getQuality</span>  raises an exception to convey the error message 
        <span class="keyword apiname">CPXERR_NO_KAPPASTATS</span>.</li>
<li class="li"><span class="keyword apiname">getUserThreads</span> always returns 1 (one).</li>
<li class="li"><span class="keyword apiname">getMyThreadNum</span> always returns 0 (zero).</li>
<li class="li"><span class="keyword apiname">getNnodes</span> returns 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">getNremainingNodes</span> returns 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">getNiterations</span> returns 0 (zero) during ramp up.</li>
</ul>
</div>

<div class="p">In the .NET API, special considerations about informational callbacks 
and distributed MIP apply to these Members (methods or properties) of the class 
<span class="keyword apiname">Cplex.MIPInfoCallback</span> and its derivatives:
    <ul class="ul"><li class="li"><span class="keyword apiname">GetNcuts</span> always returns 0 (zero).</li>
<li class="li"><span class="keyword apiname">GetQuality</span>  raises an exception to convey the error message 
        <span class="keyword apiname">CPXERR_NO_KAPPASTATS</span>.</li>
<li class="li"><span class="keyword apiname">UserThreads</span> always remains 1 (one).</li>
<li class="li"><span class="keyword apiname">MyThreadNum</span> always remains 0 (zero).</li>
<li class="li"><span class="keyword apiname">Nnodes</span> (number of nodes) remains 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">NremainingNodes</span> remains 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">Niterations</span> remains 0 (zero) during ramp up.</li>
</ul>
</div>

<div class="p">In the Python API as well, special considerations about informational callbacks 
and distributed MIP apply to these methods:
    <ul class="ul"><li class="li"><span class="keyword apiname">get_num_cuts</span> always returns 0 (zero).</li>
<li class="li"><span class="keyword apiname">get_float_quality</span>  raises an exception to convey the error message 
        <span class="keyword apiname">CPXERR_NO_KAPPASTATS</span>.</li>
<li class="li"><span class="keyword apiname">get_num_nodes</span> returns 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">get_num_remaining_nodes</span> returns 0 (zero) during ramp up.</li>
<li class="li"><span class="keyword apiname">get_num_iterations</span> returns 0 (zero) during ramp up.</li>
</ul>
</div>

<p class="p">For users of MATLAB, similar special considerations about informational callbacks 
and distributed MIP also apply.  For example, the MATLAB information object (passed 
to an informational callback during distributed MIP) reports the NumNodes property 
as 0 (zero) during ramp up, but reports accurately after ramp up terminates. 
The NumIterations property remains 0 (zero) during ramp up, too, but it is also reported 
accurately after ramp up terminates. </p>


<p class="p"> 
For examples of legacy informational callbacks, see 
these samples provided with the product:</p>

<ul class="ul"><li class="li">For users of the Callable Library (C API), see <span class="ph filepath">xdistmipex2.c</span>.</li>
<li class="li">For users of the C++ API, see <span class="ph filepath">ilodistmipex2.cpp</span>.</li>
<li class="li">For users of the Java API, see <span class="ph filepath">DistMIPEx2.java</span>.</li>
<li class="li">For users of the Python API, see <span class="ph filepath">distmipex2.py</span>.</li>
<li class="li">For users of MATLAB (Cplex class API), see <span class="ph filepath">distmipex2.m</span>.</li>
<li class="li">For users of the C#.NET API, see <span class="ph filepath">DistMIPEx2.cs</span>.</li>
</ul>
</div>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../../../../../CPLEX/UsrMan/topics/parallel_optim/distribMIP/01_distributed_mip_title_synopsis.html" title="Documents the solution in parallel of a mixed integer program (MIP) in a distributed environment">Solving a MIP with distributed parallel optimization</a></div>
</div>
</div></div></body>
</html>